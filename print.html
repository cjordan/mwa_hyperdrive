<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>mwa_hyperdrive documentation</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="mwa_hyperdrive documentation">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="././theme/css/mdbook-admonish.css">

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Installation</li><li class="chapter-item expanded "><a href="installation/intro.html"><strong aria-hidden="true">1.</strong> How do I install hyperdrive?</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="installation/pre_compiled.html"><strong aria-hidden="true">1.1.</strong> Pre-compiled</a></li><li class="chapter-item "><a href="installation/from_source.html"><strong aria-hidden="true">1.2.</strong> From source</a></li><li class="chapter-item "><a href="installation/post.html"><strong aria-hidden="true">1.3.</strong> Post installation</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="user/intro.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="user/help.html"><strong aria-hidden="true">3.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="user/di_cal/intro.html"><strong aria-hidden="true">4.</strong> DI calibration</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="user/di_cal/tutorial.html"><strong aria-hidden="true">4.1.</strong> Tutorial</a></li><li class="chapter-item "><a href="user/di_cal/simple.html"><strong aria-hidden="true">4.2.</strong> Simple usage</a></li><li class="chapter-item "><a href="user/di_cal/out_calibrated.html"><strong aria-hidden="true">4.3.</strong> Getting calibrated data</a></li><li class="chapter-item "><div><strong aria-hidden="true">4.4.</strong> Advanced usage</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="user/di_cal/advanced/time_varying.html"><strong aria-hidden="true">4.4.1.</strong> Varying solutions over time</a></li></ol></li><li class="chapter-item "><a href="user/di_cal/garrawarla.html"><strong aria-hidden="true">4.5.</strong> Usage on garrawarla</a></li></ol></li><li class="chapter-item expanded "><a href="user/solutions_apply/intro.html"><strong aria-hidden="true">5.</strong> Apply solutions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="user/solutions_apply/simple.html"><strong aria-hidden="true">5.1.</strong> Simple usage</a></li></ol></li><li class="chapter-item expanded "><a href="user/vis_simulate/intro.html"><strong aria-hidden="true">6.</strong> Simulate visibilities</a></li><li class="chapter-item expanded "><a href="user/vis_subtract/intro.html"><strong aria-hidden="true">7.</strong> Subtract visibilities</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Definitions and Concepts</li><li class="chapter-item expanded "><a href="defs/pols.html"><strong aria-hidden="true">8.</strong> Polarisations</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Supported visibility formats</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="defs/vis_formats_read.html"><strong aria-hidden="true">9.1.</strong> Read</a></li><li class="chapter-item "><a href="defs/vis_formats_write.html"><strong aria-hidden="true">9.2.</strong> Write</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> MWA-specific details</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="defs/mwa/metafits.html"><strong aria-hidden="true">10.1.</strong> Metafits files</a></li><li class="chapter-item "><a href="defs/mwa/delays.html"><strong aria-hidden="true">10.2.</strong> Dipole delays</a></li><li class="chapter-item "><a href="defs/mwa/dead_dipoles.html"><strong aria-hidden="true">10.3.</strong> Dead dipoles</a></li><li class="chapter-item "><a href="defs/mwa/mwaf.html"><strong aria-hidden="true">10.4.</strong> mwaf flag files</a></li><li class="chapter-item "><a href="defs/mwa/corrections.html"><strong aria-hidden="true">10.5.</strong> Raw data corrections</a></li><li class="chapter-item "><a href="defs/mwa/mwalib.html"><strong aria-hidden="true">10.6.</strong> mwalib</a></li></ol></li><li class="chapter-item expanded "><a href="defs/source_lists.html"><strong aria-hidden="true">11.</strong> Sky-model source lists</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="defs/fd_types.html"><strong aria-hidden="true">11.1.</strong> Flux-density types</a></li><li class="chapter-item "><a href="defs/source_list_hyperdrive.html"><strong aria-hidden="true">11.2.</strong> hyperdrive format</a></li><li class="chapter-item "><a href="defs/source_list_ao.html"><strong aria-hidden="true">11.3.</strong> André Offringa (ao) format</a></li><li class="chapter-item "><a href="defs/source_list_rts.html"><strong aria-hidden="true">11.4.</strong> RTS format</a></li></ol></li><li class="chapter-item expanded "><a href="defs/cal_sols.html"><strong aria-hidden="true">12.</strong> Calibration solutions file formats</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="defs/cal_sols_hyp.html"><strong aria-hidden="true">12.1.</strong> hyperdrive format</a></li><li class="chapter-item "><a href="defs/cal_sols_ao.html"><strong aria-hidden="true">12.2.</strong> André Offringa (ao) format</a></li><li class="chapter-item "><a href="defs/cal_sols_rts.html"><strong aria-hidden="true">12.3.</strong> RTS format</a></li></ol></li><li class="chapter-item expanded "><a href="defs/beam.html"><strong aria-hidden="true">13.</strong> Beam responses</a></li><li class="chapter-item expanded "><a href="defs/modelling/intro.html"><strong aria-hidden="true">14.</strong> Modelling visibilities</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="defs/modelling/rime.html"><strong aria-hidden="true">14.1.</strong> Measurement equation</a></li><li class="chapter-item "><a href="defs/modelling/estimating.html"><strong aria-hidden="true">14.2.</strong> Estimating flux densities</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Terminology</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="defs/blocks.html"><strong aria-hidden="true">15.1.</strong> Timeblocks and chanblocks</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Developer Guide</li><li class="chapter-item expanded "><a href="dev/ndarray.html"><strong aria-hidden="true">16.</strong> Multiple-dimension arrays (ndarray)</a></li><li class="chapter-item expanded "><a href="dev/vec1.html"><strong aria-hidden="true">17.</strong> Non-empty vectors (vec1)</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">mwa_hyperdrive documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/MWATelescope/mwa_hyperdrive" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<div align="center">
  <img src="hyperdrive.png" height="200px" alt="hyperdrive logo">
</div>
<p><code>mwa_hyperdrive</code> (simply referred to as <code>hyperdrive</code>) is calibration software
for the Murchison Widefield Array radio telescope. The documentation contained
in this book aims to help understand how to use it and how it works.</p>
<p>Some of the more useful parts of this documentation might be:</p>
<ul>
<li>
<p>an <a href="installation/intro.html">installation guide</a>;</p>
</li>
<li>
<p>a <a href="user/intro.html">user guide</a>; e.g.</p>
<ul>
<li><a href="user/help.html">How do I use the program?</a></li>
<li><a href="user/di_cal/intro.html">What does DI calibration do?</a></li>
<li><a href="user/di_cal/tutorial.html">How do I get started with DI calibration?</a></li>
</ul>
</li>
<li>
<p>definitions and concepts; e.g.</p>
<ul>
<li><a href="defs/source_lists.html">What are supported sky-model source list formats?</a></li>
<li><a href="defs/pols.html">How are XX, XY, YX, YY defined?</a></li>
<li><a href="defs/blocks.html">What is a calibration timeblock?</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>The easiest way to get access to <code>hyperdrive</code> is to download a pre-compiled
binary from GitHub. Instructions are on <a href="installation/pre_compiled.html">the next page</a>.</p>
<p>However, you may need to compile <code>hyperdrive</code> from source. If so, see the
instructions <a href="installation/from_source.html">here</a> (note that the code will likely run faster
if you compile it from source).</p>
<p>Finally, regardless of how you get the <code>hyperdrive</code> binary, follow the <a href="installation/post.html">post
installation</a> instructions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-hyperdrive-from-pre-compiled-binaries"><a class="header" href="#installing-hyperdrive-from-pre-compiled-binaries">Installing <code>hyperdrive</code> from pre-compiled binaries</a></h1>
<p>Visit the <a href="https://github.com/MWATelescope/mwa_hyperdrive/releases">GitHub releases page</a>. You should see releases like the following:</p>
<p><img src="installation/release_example.png" alt="Release example" /></p>
<ul>
<li>Under &quot;Assets&quot;, download one of the <code>tar.gz</code> files starting with
<code>mwa_hyperdrive</code>;</li>
<li>Untar it (e.g. <code>tar -xvf mwa_hyperdrive*.tar.gz</code>); and</li>
<li>Run the binary (<code>./hyperdrive</code>).</li>
</ul>
<p>If you intend on running <code>hyperdrive</code> on a desktop GPU, then you probably want
the &quot;CUDA-single&quot; release. You can still use the double-precision version on a
desktop GPU, but it will be much slower than single-precision. Instructions to
install CUDA are on <a href="installation/from_source.html#cuda">the next page</a>.</p>
<pre><code class="language-admonish">The pre-compiled binaries are made by GitHub actions using:
```shell
cargo build --release --locked --no-default-features --features=hdf5-static,erfa-static,cfitsio-static
```
This means they cannot plot calibration solutions.
&quot;CUDA-double&quot; binaries have the `cuda` feature and &quot;CUDA-single&quot; binaries have
the `cuda-single` feature. CUDA cannot legally be statically linked so a local
installation of CUDA is required.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-hyperdrive-from-source-code"><a class="header" href="#installing-hyperdrive-from-source-code">Installing <code>hyperdrive</code> from source code</a></h1>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p><code>hyperdrive</code> depends on these C libraries:</p>
<pre><code class="language-admonish example title=&quot;[cfitsio](https://heasarc.gsfc.nasa.gov/docs/software/fitsio/)&quot;">- Ubuntu: `libcfitsio-dev`
- Arch: `cfitsio`
- Library and include dirs can be specified manually with `CFITSIO_LIB` and
  `CFITSIO_INC`
  - If not specified, `pkg-config` is used to find the library.
- Can compile statically; use the `cfitsio-static` or `all-static` features.
  - Requires a C compiler and `autoconf`.
</code></pre>
<pre><code class="language-admonish example title=&quot;[ERFA](https://github.com/liberfa/erfa)&quot;">- Ubuntu: `liberfa-dev`
- Arch: AUR package `erfa`
- The library dir can be specified manually with `ERFA_LIB`
  - If not specified, `pkg-config` is used to find the library.
- Can compile statically; use the `erfa-static` or `all-static` features.
  - Requires a C compiler and `autoconf`.
</code></pre>
<pre><code class="language-admonish example title=&quot;[hdf5](https://www.hdfgroup.org/hdf5)&quot;">- Ubuntu: `libhdf5-dev`
- Arch: `hdf5`
- The library dir can be specified manually with `HDF5_DIR`
  - If not specified, `pkg-config` is used to find the library.
- Can compile statically; use the `hdf5-static` or `all-static` features.
  - Requires `CMake` version 3.10 or higher.
</code></pre>
<h3 id="optional-dependencies"><a class="header" href="#optional-dependencies">Optional dependencies</a></h3>
<pre><code class="language-admonish tip title=&quot;freetype2 (for calibration solutions plotting)&quot;">- Only needed if the `plotting` feature is enabled (which it is by default)
- Arch: `pkg-config` `make` `cmake` `freetype2`
- Ubuntu: `libfreetype-dev` `libexpat1-dev`
</code></pre>
<pre><code class="language-admonish tip title=&quot;[CUDA](https://developer.nvidia.com/cuda-zone) (for accelerated sky modelling)&quot;">- Only needed if either the `cuda` or `cuda-single` feature is enabled
- Arch: `cuda`
- The library dir can be specified manually with `CUDA_LIB`
  - If not specified, `/usr/local/cuda` and `/opt/cuda` are searched.
- Can link statically; use the `cuda-static` or `all-static` features.
</code></pre>
<h2 id="installing-rust"><a class="header" href="#installing-rust">Installing Rust</a></h2>
<pre><code class="language-admonish tip title=&quot;TL;DR&quot;">```shell
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```
</code></pre>
<p><code>hyperdrive</code> is written in <a href="https://www.rust-lang.org/">Rust</a>, so a Rust
environment is required. <a href="https://doc.rust-lang.org/book/ch01-01-installation.html">The Rust
book</a> has excellent
information to do this. Similar, perhaps more direct information is
<a href="https://www.rust-lang.org/tools/install">here</a>.</p>
<p><strong>Do not</strong> use <code>apt</code> to install Rust components.</p>
<h2 id="cloning-the-hyperdrive-repo"><a class="header" href="#cloning-the-hyperdrive-repo">Cloning the <code>hyperdrive</code> repo</a></h2>
<pre><code class="language-shell">git clone https://github.com/MWATelescope/mwa_hyperdrive
</code></pre>
<p>Don't forget to <code>cd</code> into the repo:</p>
<pre><code class="language-shell">cd mwa_hyperdrive
</code></pre>
<h2 id="compiling-hyperdrive"><a class="header" href="#compiling-hyperdrive">Compiling <code>hyperdrive</code></a></h2>
<pre><code class="language-shell">cargo install --path . --locked
</code></pre>
<p>This will install <code>hyperdrive</code> to <code>~/.cargo/bin/hyperdrive</code>. This binary can be
moved anywhere and it will still work. The installation destination can be
changed by setting <code>CARGO_HOME</code>.</p>
<pre><code class="language-admonish danger title=&quot;CUDA&quot;">Do you have a CUDA-capable NVIDIA GPU? Ensure you have installed
[CUDA](https://developer.nvidia.com/cuda-zone) (instructions are above), find
your CUDA device's compute capability
[here](https://developer.nvidia.com/cuda-gpus) (e.g. Geforce RTX 2070 is 7.5),
and set a variable with this information (note the lack of a period in the
number):

```shell
export HYPERDRIVE_CUDA_COMPUTE=75
```

Now you can compile `hyperdrive` with CUDA enabled (single-precision floats):

```shell
cargo install --path . --locked --features=cuda-single
```

If you're using &quot;datacentre&quot; products (e.g. a V100 available on the
Pawsey-hosted supercomputer &quot;garrawarla&quot;), you probably want double-precision
floats:

```shell
cargo install --path . --locked --features=cuda
```

You can still compile with double-precision on a desktop GPU, but it will be
much slower than single-precision.
</code></pre>
<pre><code class="language-admonish tip title=&quot;Static dependencies&quot;">The aforementioned C libraries can each be compiled by `cargo`. `all-static`
will statically-link all dependencies (including CUDA, if CUDA is enabled) such
that **you need not have these libraries available to use `hyperdrive`**.
Individual dependencies can be statically compiled and linked, e.g.
`cfitsio-static`. See the dependencies list above for more information.
</code></pre>
<pre><code class="language-admonish info title=&quot;Multiple features&quot;">`cargo` features can be chained in a comma-separated list:

```shell
cargo install --path . --locked --features=cuda,all-static
```
</code></pre>
<pre><code class="language-admonish help title=&quot;Troubleshooting&quot;">If you're having problems compiling, it's possible you have an older Rust
toolchain installed. Try updating it:

```shell
rustup update
```

If that doesn't help, try cleaning the local build directories:

```shell
cargo clean
```

and try compiling again. If you're still having problems, raise a [GitHub
issue](https://github.com/MWATelescope/mwa_hyperdrive/issues) describing your
system and what you've tried.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="post-installation-instructions"><a class="header" href="#post-installation-instructions">Post installation instructions</a></h1>
<pre><code class="language-admonish info title=&quot;Setting up the beam&quot;">
Many `hyperdrive` functions require the beam code to function. The MWA FEE beam
HDF5 file can be obtained with:

```shell
wget http://ws.mwatelescope.org/static/mwa_full_embedded_element_pattern.h5
```

Move the `h5` file anywhere you like, and put the file path in the
`MWA_BEAM_FILE` environment variable:

```shell
export MWA_BEAM_FILE=/path/to/mwa_full_embedded_element_pattern.h5
```

See the README for [`hyperbeam`](https://github.com/MWATelescope/mwa_hyperbeam)
for more info.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h1>
<p><code>hyperdrive</code> aims to make users' lives as easy as possible. Commands should
<em>always</em> have good quality help text, errors and output messages. However, users
may have questions that the <code>hyperdrive</code> binary itself cannot answer; that's
where this documentation comes in.</p>
<p>If ever you find <code>hyperdrive</code>'s help text lacking or this documentation doesn't
answer your question, feel free to file an
<a href="https://github.com/MWATelescope/mwa_hyperdrive/issues">issue</a> (or even better,
file a <a href="https://github.com/MWATelescope/mwa_hyperdrive/pulls">PR</a>!).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>Do you want to do some calibration, but don't know how to start? Can't remember
what that command-line argument is called? If ever you're in doubt, consult the
help text:</p>
<pre><code class="language-shell"># Top-level help
hyperdrive --help

# di-calibrate help
hyperdrive di-calibrate --help
</code></pre>
<p><code>di-calibrate</code> is one of many subcommands. Subcommands are accessed by typing
them after <code>hyperdrive</code>. Each subcommand accepts <code>--help</code> (as well as <code>-h</code>).
Detailed usage information on each subcommand can be seen in the table of
contents of this book. More information on subcommands as a concept is below.</p>
<pre><code class="language-admonish info title=&quot;Subcommands&quot;">
`hyperdrive` itself is split into many subcommands. These are simple to list:

```shell
hyperdrive -h
# OR
hyperdrive --help
```

Output (edited for brevity):

```plaintext
SUBCOMMANDS:
    di-calibrate
    vis-simulate
    solutions-convert
    solutions-plot
    srclist-by-beam
```

The help text for these is accessible in a similar way:

```shell
hyperdrive solutions-plot -h
# OR
hyperdrive solutions-plot --help
```

```plaintext
hyperdrive-solutions-plot 0.2.0-alpha.11
Plot calibration solutions. Only available if compiled with the &quot;plotting&quot; feature.

USAGE:
    hyperdrive solutions-plot [OPTIONS] [SOLUTIONS_FILES]...

ARGS:
    &lt;SOLUTIONS_FILES&gt;...

OPTIONS:
    -r, --ref-tile &lt;REF_TILE&gt;    The reference tile to use. If this isn't specified, the best one from the end is used
    -n, --no-ref-tile            Don't use a reference tile. Using this will ignore any input for `ref_tile`
        --ignore-cross-pols      Don't plot XY and YX polarisations
        --min-amp &lt;MIN_AMP&gt;      The minimum y-range value on the amplitude gain plots
        --max-amp &lt;MAX_AMP&gt;      The maximum y-range value on the amplitude gain plots
    -m, --metafits &lt;METAFITS&gt;    The metafits file associated with the solutions. This provides additional information on the plots, like the tile names
    -v, --verbosity              The verbosity of the program. Increase by specifying multiple times (e.g. -vv). The default is to print only high-level information
    -h, --help                   Print help information
    -V, --version                Print version information
```
</code></pre>
<pre><code class="language-admonish tip title=&quot;Shortcuts&quot;">
It's possible to save keystrokes when subcommands aren't ambiguous, e.g. use
`solutions-p` as an alias for `solutions-plot`:

```shell
hyperdrive solutions-p
&lt;help text for &quot;solutions-plot&quot;&gt;
```

This works because there is no other subcommand that `solutions-p` could refer
to. On the other hand, `solutions` won't be accepted because both
`solutions-plot` and `solutions-convert` exist.

`di-c` works for `di-calibrate`. Unfortunately this is not perfect; the `-` is
required even though `di` should be enough.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="di-calibration"><a class="header" href="#di-calibration">DI calibration</a></h1>
<p>Direction-Independent (DI) calibration &quot;corrects&quot; raw telescope data.
<code>hyperdrive</code> achieves this with &quot;sky model calibration&quot;. This can work very
well, but relies on two key assumptions:</p>
<ul>
<li>The sky model is an accurate reflection of the input data; and</li>
<li>The input data are not too contaminated (e.g. by radio-frequency
interference).</li>
</ul>
<p>A high-level overview of the steps in <code>di-calibrate</code> are below. Solid lines
indicate actions that always happen, dashed lines are optional:</p>
<pre class="mermaid">%%{init: {'theme':'dark', 'themeVariables': {'fontsize': 20}}}%%
flowchart TD
    InputData[fa:fa-file Input data files]--&gt;Args
    SkyModel[fa:fa-file Sky-model source-list file]--&gt;Args
    Settings[fa:fa-cog Other settings]-.-&gt;Args

    Args[fa:fa-cog User arguments]--&gt;Valid{fa:fa-code Valid?}
    Valid --&gt; cal

    subgraph cal[For all timeblocks]
        Read[fa:fa-code Read a timestep\nof input data]
        Model[&quot;fa:fa-code Generate model vis\n (CPU or GPU)&quot;]
        Model-.-&gt;WriteModelVis[fa:fa-save Write model visibilities]

        LSQ[fa:fa-code Calibrate via least squares]
        Read--&gt;LSQ
        Model--&gt;LSQ
        LSQ--&gt;|Iterate|LSQ
        LSQ--&gt;Sols[fa:fa-wrench Accumulate\ncalibration solutions]
    end

    cal--&gt;WriteSols[fa:fa-save Write calibration solutions]
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="di-calibration-tutorial"><a class="header" href="#di-calibration-tutorial">DI calibration tutorial</a></h1>
<p>Here, a series of steps are laid out to demonstrate how raw MWA data is
calibrated with <code>hyperdrive</code>. We also plot calibration solutions and image
calibrated data with <code>wsclean</code>.</p>
<p><a href="user/di_cal/../../installation/intro.html">Install</a> <code>hyperdrive</code> if you haven't already.</p>
<pre><code class="language-admonish example title=&quot;Step 1: Obtain data&quot;">Feel free to try your own data, but test data is available in the `hyperdrive`
repo; download it with this command:

```shell
git clone https://github.com/MWATelescope/mwa_hyperdrive --depth 1
cd mwa_hyperdrive
```

The files are `test_files/1090008640/1090008640_20140721201027_gpubox01_00.fits`
and `test_files/1090008640/1090008640.metafits`. This is tiny part of the [real
1090008640
observation](http://ws.mwatelescope.org/observation/obs/?obs_id=1090008640) used
in `hyperdrive` tests.
</code></pre>
<pre><code class="language-admonish example title=&quot;Step 2: Obtain a suitable sky-model source list&quot;">
It's very important to use a sky model that corresponds to the data you're
using. For EoR fields, [srclists](https://github.com/JLBLine/srclists) contains
many suitable source lists.

Here, a source list is already provided for testing:
`test_files/1090008640/srclist_pumav3_EoR0aegean_EoR1pietro+ForA_1090008640_100.yaml`.
</code></pre>
<pre><code class="language-admonish example title=&quot;Step 3: Run&quot;">
We're going to run the `di-calibrate` subcommand of `hyperdrive`. If you look at
the help (with `hyperdrive di-calibrate --help`), you should see the `--data`
(`-d` for short) and `--source-list` (`-s` for short) flags under an `INPUT
FILES` header. These are the only two things needed to do calibration:

```shell
hyperdrive di-calibrate -d test_files/1090008640/1090008640_20140721201027_gpubox01_00.fits test_files/1090008640/1090008640.metafits -s test_files/1090008640/srclist_pumav3_EoR0aegean_EoR1pietro+ForA_1090008640_100.yaml
```
</code></pre>
<pre><code class="language-admonish tip">The above command can be more neatly expressed as:
```shell
hyperdrive di-calibrate \
    -d test_files/1090008640/1090008640_20140721201027_gpubox01_00.fits \
       test_files/1090008640/1090008640.metafits \
    -s test_files/1090008640/srclist_pumav3_EoR0aegean_EoR1pietro+ForA_1090008640_100.yaml
```
This isn't specific to `hyperdrive`; this is just telling your shell to use
multiple lines separated by `\`.
</code></pre>
<pre><code class="language-admonish example title=&quot;Step 4: Understanding the output&quot;">
The command we ran in step 3 should give us information on the input data, the
sky model, any output files, as well as things relating to calibration. One line reports:

```plaintext
Reading input data and sky modelling
```

This indicates that `hyperdrive` is reading the data from disk and generating
model visibilities. This is usually the slowest part of the whole process, so
depending on your inputs, this could take some time. You should also see some
progress bars related to these two tasks.

Once the progress bars are finished, calibration can begin. You should see many lines like:

```plaintext
Chanblock  11: converged (50): 1e-4 &gt; 9.57140e-7 &gt; 1e-8
```

This indicates three things:
- Chanblock 11 converged;
- 50 iterations were performed; and
- The final error was 9.57140e-7, which is between 1e-4 and 1e-8.
</code></pre>
<pre><code class="language-admonish info title=&quot;What do these things mean?&quot;">A [&quot;chanblock&quot;](../../defs/blocks.md) is a frequency unit of calibration;
it may correspond to one or many channels of the input data.

Calibration is done iteratively; it iterates until the &quot;stop threshold&quot; is
reached, or up to a set number of times. The &quot;stop&quot; and &quot;minimum&quot; thresholds
are used during convergence. If the stop threshold is reached before the maximum
number of iterations, we say that the chanblock has converged well enough that
we can stop iterating. However, if we reach the maximum number of iterations,
one of two things happens:

- The chanblock convergence has not reached the stop threshold but exceed the
  minimum threshold.
  - In this case, we say the chanblock converged and note that it didn't reach
    the stop threshold.
- The chanblock convergence has not reached either the stop or minimum (1e-4
  by default) thresholds.
  - In this case, we say the chanblock did not converge (&quot;failed&quot;).

All of these calibration parameters (maximum iterations, stop threshold,
minimum threshold) are allowed to be adjusted.
</code></pre>
<pre><code class="language-admonish example title=&quot;Step 5: Analyse&quot;">Don't assume that things will always work! A good indicator of how calibration
went is given toward the end of the output of `di-calibrate`:

```plaintext
All timesteps: 27/27 (100%) chanblocks converged
```

In this case, all chanblocks converged, giving us confidence that things went
OK. But there are other things we can do to inspect calibration quality; good
examples are plotting the solutions, and imaging the calibrated data.
</code></pre>
<pre><code class="language-admonish example title=&quot;Plotting solutions&quot;">
First, we need to know where the solutions were written; this is also reported
toward the end of the output of `di-calibrate`:

```plaintext
INFO  Calibration solutions written to hyperdrive_solutions.fits
```

So the solutions are at `hyperdrive_solutions.fits`. We can make plots with `solutions-plot`; i.e.

```shell
hyperdrive solutions-plot hyperdrive_solutions.fits
```

The command should give output like this:

```plaintext
INFO  Wrote [&quot;hyperdrive_solutions_amps.png&quot;, &quot;hyperdrive_solutions_phases.png&quot;]
```

These plots should look something like this:

![](amps.png)
![](phases.png)

Each box corresponds to an MWA tile and each tile has dots plotted for each
channel we calibrated. The dots are really hard to see because there are only 27
channels with solutions. However, if we look _very_ closely, we can see that,
generally, the dot values don't change much with frequency (particularly for the
amps), or the dot values change steadily with frequency (particularly for the
phases). This also hints that the calibration solutions are good.
</code></pre>
<pre><code class="language-admonish info">The solutions plots for the full 1090008640 observation look like this:

![](amps_full.jpg)
![](phases_full.jpg)

Things are much easier to see when there are more dots! As before, changes
with frequency are small or smooth.

More information on the calibration solutions file formats can be seen
[here](../../defs/cal_sols.md).
</code></pre>
<pre><code class="language-admonish example title=&quot;Imaging calibrated data&quot;">We have calibration solutions, but not calibrated data. We need to &quot;apply&quot; the
solutions to data to calibrate them:

```shell
hyperdrive solutions-apply \
    -d test_files/1090008640/1090008640_20140721201027_gpubox01_00.fits \
       test_files/1090008640/1090008640.metafits \
    -s hyperdrive_solutions.fits \
    -o hyp_cal.ms
```

This will write calibrated visibilities to `hyp_cal.ms`. Now we can image the
measurement set with [`wsclean`](https://gitlab.com/aroffringa/wsclean):

```shell
wsclean -size 4096 4096 -scale 40asec -niter 1000 -auto-threshold 3 hyp_cal.ms
```

This writes an image file to `wsclean-image.fits`. You can use many FITS file
viewers to inspect the image, but here's what it looks like with
[DS9](https://sites.google.com/cfa.harvard.edu/saoimageds9):

![](calibrated.jpg)

Sources are visible! Generally the image quality is OK, but not great. This is
because there was very little input data.
</code></pre>
<pre><code class="language-admonish info">When using the [full 1090008640
observation](http://ws.mwatelescope.org/observation/obs/?obs_id=1090008640),
this is what the same image looks like (note that unlike the above image, &quot;sqrt&quot;
scaling is used):

![](calibrated_full.jpg)

Many more sources are visible, and the noise is much lower. Depending on your
science case, these visibilities might be &quot;science ready&quot;.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-usage-of-di-calibrate"><a class="header" href="#simple-usage-of-di-calibrate">Simple usage of DI calibrate</a></h1>
<pre><code class="language-admonish info">DI calibration is done with the `di-calibrate` subcommand, i.e.

```shell
hyperdrive di-calibrate
```

At the very least, this requires:
- Input data (with the flag `-d`)
  - [Supported formats](../../defs/vis_formats_read.md)
- A sky model (with the flag `-s`)
  - [Supported formats](../../defs/source_lists.md)
  - PUMA sky models suitable for EoR calibration (and perhaps other parts of the
    sky) can be obtained [here](https://github.com/JLBLine/srclists) (at the time of writing [srclist_pumav3_EoR0aegean_fixedEoR1pietro+ForA_phase1+2.txt](https://github.com/JLBLine/srclists/blob/master/srclist_pumav3_EoR0aegean_fixedEoR1pietro%2BForA_phase1%2B2.txt) is preferred)
</code></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<pre><code class="language-admonish example title=&quot;Raw MWA data&quot;">A [metafits](../../defs/mwa/metafits.md) file is always required when reading
raw MWA data. [`mwaf`](../../defs/mwa/mwaf.md) files are optional.

For &quot;legacy&quot; MWA data:

```shell
hyperdrive di-calibrate -d *gpubox*.fits *.metafits *.mwaf -s a_good_sky_model.yaml
```

or for MWAX:

```shell
hyperdrive di-calibrate -d *ch???*.fits *.metafits *.mwaf -s a_good_sky_model.yaml
```
</code></pre>
<pre><code class="language-admonish example title=&quot;Measurement sets&quot;">Note that a metafits may not be required, but is generally a good idea.

```shell
hyperdrive di-calibrate -d *.ms *.metafits -s a_good_sky_model.yaml
```
</code></pre>
<pre><code class="language-admonish example title=&quot;uvfits&quot;">Note that a metafits may not be required, but is generally a good idea.

```shell
hyperdrive di-calibrate -d *.uvfits *.metafits -s a_good_sky_model.yaml
```
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-out-calibrated-data"><a class="header" href="#writing-out-calibrated-data">Writing out calibrated data</a></h1>
<p><code>di-calibrate</code> does not write out calibrated data (visibilities); see
<a href="user/di_cal/../solutions_apply/intro.html"><code>solutions-apply</code></a>. You will need calibration
solutions, so refer to the previous pages on DI calibration to get those.</p>
<pre><code class="language-admonish tip">Calibrated visibilities are written out in one of the [supported
formats](../../defs/vis_formats_write.md) and can be
[averaged](../../defs/vis_formats_write.md#visibility-averaging).
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="varying-solutions-over-time"><a class="header" href="#varying-solutions-over-time">Varying solutions over time</a></h1>
<pre><code class="language-admonish tip">See [this page](../../../defs/blocks.md) for information on timeblocks.
</code></pre>
<p>By default, <code>di-calibrate</code> uses only one &quot;timeblock&quot;, i.e. all data timesteps
are averaged together during calibration. This provides good signal-to-noise,
but it is possible that calibration is improved by taking time variations into
account. This is done with <code>--timesteps-per-timeblock</code> (<code>-t</code> for short).</p>
<p>If <code>--timesteps-per-timeblock</code> is given a value of 4, then every 4 timesteps are
calibrated together and written out as a timeblock. Values with time units (e.g.
<code>8s</code>) are also accepted; in this case, every 8 seconds worth of data are
averaged during calibration and written out as a timeblock.</p>
<p>Depending on the number of timesteps in the data, using <code>-t</code> could result in
<em>many</em> timeblocks written to the calibration solutions. Each solution timeblock
is plotted when these solutions are given to <code>solutions-plot</code>. For each timestep
in question, the best solution timeblock is used when running <code>solutions-apply</code>.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>When multiple timeblocks are to be made, <code>hyperdrive</code> will do a pass of
calibration using <em>all</em> timesteps to provide each timeblock's calibration with a
good &quot;initial guess&quot; of what their solutions should be.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage-on-garrawarla"><a class="header" href="#usage-on-garrawarla">Usage on garrawarla</a></h1>
<p><a href="https://support.pawsey.org.au/documentation/display/US/Garrawarla+Documentation">garrawarla</a>
is a supercomputer dedicated to MWA activities hosted by the Pawsey
Supercomputing Centre. It uses
<a href="https://slurm.schedmd.com/overview.html"><code>Slurm</code></a> for its job scheduling.</p>
<h2 id="getting-access"><a class="header" href="#getting-access">Getting access</a></h2>
<p><code>hyperdrive</code> has been installed on garrawarla, but not by Pawsey. For this
reason, an extra command is needed to get access to it:</p>
<pre><code class="language-shell">module use /pawsey/mwa/software/python3/modulefiles
</code></pre>
<p>You should then be able to see multiple versions of <code>hyperdrive</code> to use:</p>
<pre><code class="language-shell">module avail hyperdrive

---------------- /pawsey/mwa/software/python3/modulefiles ----------------
   hyperdrive/chj            (L)        hyperdrive/v0.2.0-alpha10
   hyperdrive/v0.2.0-alpha11 (D)

  Where:
   D:  Default Module
   L:  Module is loaded
</code></pre>
<p>To use the default version, just run:</p>
<pre><code class="language-shell">module load hyperdrive
</code></pre>
<p>To use a specific version, provide it to the <code>load</code> command, e.g.:</p>
<pre><code class="language-shell">module load hyperdrive/v0.2.0-alpha11
</code></pre>
<h2 id="running-interactively"><a class="header" href="#running-interactively">Running interactively</a></h2>
<p>Testing your command interactively <em>before</em> using <code>Slurm</code> scripts could save you
some time.</p>
<ol>
<li>Use <code>salloc</code> to request a node:</li>
</ol>
<pre><code class="language-shell">salloc --partition gpuq --time 1:00:00 --nodes 1 --gres=gpu:1 --cpus-per-task 40
</code></pre>
<ol start="2">
<li>Get access to <code>hyperdrive</code>, e.g.:</li>
</ol>
<pre><code class="language-shell">module use /pawsey/mwa/software/python3/modulefiles
module load hyperdrive/v0.2.0-alpha11
</code></pre>
<ol start="3">
<li>Run your command (see examples of usage in the previous sections of this
book).</li>
</ol>
<p>Note the <code>--cpus-per-task</code> given to <code>salloc</code>; using more CPUs will make some
aspects of <code>di-calibrate</code> run faster. It's probably not a good idea to use less
than 10, and the maximum is 40.</p>
<p>It is possible to run <code>hyperdrive</code> without a GPU, but generating model
visibilities will be much slower.</p>
<h2 id="example-slurm-script"><a class="header" href="#example-slurm-script">Example <code>Slurm</code> script</a></h2>
<pre><code class="language-plaintext">#!/bin/bash -l
#SBATCH --job-name=hyp-$1
#SBATCH --output=hyperdrive.out
#SBATCH --nodes=1
#SBATCH --ntasks-per-node=40
#SBATCH --time=01:00:00
#SBATCH --clusters=garrawarla
#SBATCH --partition=gpuq
#SBATCH --account=mwaeor
#SBATCH --export=NONE
#SBATCH --gres=gpu:1,tmp:50g

module use /pawsey/mwa/software/python3/modulefiles
module load hyperdrive

set -eux
command -v hyperdrive

cd /astro/mwaeor/MWA/data/1090008640

# Get calibration solutions. Use the top 1000 sources.
hyperdrive di-calibrate \
    -s /pawsey/mwa/software/python3/srclists/master/srclist_pumav3_EoR0aegean_fixedEoR1pietro+ForA_phase1+2.txt \
    -n 1000
    -d *gpubox*.fits *.metafits *.mwaf \
    -o hyp_sols.fits

# Apply the solutions and write out a measurement set.
# Write it to /nvmetmp as that's much faster than /astro.
hyperdrive solutions-apply \
    -d *gpubox*.fits *.metafits *.mwaf \
    -s hyp_sols.fits \
    -o /nvmetmp/hyp_calibrated.ms \
    --time-average 8s \
    --freq-average 80kHz

# Move the measurement set to /astro.
mv /nvmetmp/hyp_calibrated.ms .
</code></pre>
<p>This example script reserves 50 GB of space for node local storage (<code>/nvmetmp</code>).
If your output visibilities are bigger than this, then the write will fail; you
should adjust the <code>#SBATCH --gres=tmp:50g</code> line to account for this, e.g.
<code>#SBATCH --gres=tmp:200g</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solutions-apply"><a class="header" href="#solutions-apply">Solutions apply</a></h1>
<p><code>solutions-apply</code> takes calibration solutions and applies them to input
visibilities before writing out visibilities. All input formats are supported,
however <code>hyperdrive</code>-style calibration solutions are preferred because they are
unambiguous when applying multiple timeblocks.</p>
<p><code>apply-solutions</code> can be used instead of <code>solutions-apply</code>.</p>
<p>A high-level overview of the steps in <code>solutions-apply</code> are below. Solid lines
indicate actions that always happen, dashed lines are optional:</p>
<pre class="mermaid">%%{init: {'theme':'dark', 'themeVariables': {'fontsize': 20}}}%%
flowchart TD
    InputData[fa:fa-file Input data files]--&gt;Args
    CalSols[fa:fa-wrench Calibration\nsolutions]--&gt;Args
    Settings[fa:fa-cog Other settings]-.-&gt;Args

    Args[fa:fa-cog User arguments]--&gt;Valid{fa:fa-code Valid?}
    Valid --&gt; apply

    subgraph apply[For all timesteps]
        Read[fa:fa-code Read a timestep\nof input data]
        Read--&gt;Apply[&quot;fa:fa-code Apply calibration\nsolutions to timeblock&quot;]
        Apply--&gt;Write[fa:fa-save Write timeblock\nvisibilities]
    end
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-usage-of-solutions-apply"><a class="header" href="#simple-usage-of-solutions-apply">Simple usage of solutions apply</a></h1>
<pre><code class="language-admonish info">Use the `solutions-apply` subcommand, i.e.

```shell
hyperdrive solutions-apply
```

At the very least, this requires:
- Input data (with the flag `-d`)
  - [Supported formats](../../defs/vis_formats_read.md)
- Calibration solutions (with the flag `-s`)
  - [Supported formats](../../defs/cal_sols.md)
</code></pre>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<pre><code class="language-admonish example title=&quot;From raw MWA data&quot;">```shell
hyperdrive solutions-apply -d *gpubox*.fits *.metafits *.mwaf -s hyp_sols.fits -o hyp_cal.ms
```
</code></pre>
<pre><code class="language-admonish example title=&quot;From an uncalibrated measurement set&quot;">```shell
hyperdrive solutions-apply -d *.ms -s hyp_sols.fits -o hyp_cal.ms
```
</code></pre>
<pre><code class="language-admonish example title=&quot;From an uncalibrated uvfits&quot;">```shell
hyperdrive solutions-apply -d *.uvfits -s hyp_sols.fits -o hyp_cal.ms
```
</code></pre>
<p>Generally the syntax is the same as <a href="user/solutions_apply/../di_cal/simple.html"><code>di-calibrate</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simulate-visibilities"><a class="header" href="#simulate-visibilities">Simulate visibilities</a></h1>
<p><code>vis-simulate</code> effectively turns a sky-model source list into visibilities.</p>
<pre><code class="language-admonish info title=&quot;Simple example&quot;">```shell
hyperdrive vis-simulate \
    -s srclist.yaml \
    -m *.metafits
```
</code></pre>
<h2 id="considerations"><a class="header" href="#considerations">Considerations</a></h2>
<h3 id="disabling-beam-attenuation"><a class="header" href="#disabling-beam-attenuation">Disabling beam attenuation</a></h3>
<p><code>--no-beam</code></p>
<h3 id="dead-dipoles"><a class="header" href="#dead-dipoles">Dead dipoles</a></h3>
<p>By default, <a href="user/vis_simulate/../../defs/mwa/dead_dipoles.html">dead dipoles</a> in the
<a href="user/vis_simulate/../../defs/mwa/metafits.html">metafits</a> are used. These will affect the generated
visibilities. You can disable them with <code>--unity-dipole-gains</code>.</p>
<h3 id="vetoing"><a class="header" href="#vetoing">Vetoing</a></h3>
<p>Source-list vetoing can do unexpected things. You can effectively disable it by
supplying <code>--veto-threshold 0</code>, although the veto routine will still:</p>
<ol>
<li>Remove sources below the horizon; and</li>
<li>Sort the remaining sources by brightness based off of the centre frequencies
MWA coarse channels.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subtract-visibilities"><a class="header" href="#subtract-visibilities">Subtract visibilities</a></h1>
<p><code>vis-subtract</code> can subtract the sky-model visibilities from calibrated data
visibilities and write them out. This can be useful to see how well the sky
model agrees with the input data, although direction-dependent effects (e.g. the
ionosphere) may be present and produce &quot;holes&quot; in the visibilities, e.g.:</p>
<p><img src="user/vis_subtract/subtracted.jpg" alt="" /></p>
<p>A high-level overview of the steps in <code>vis-subtract</code> are below. Solid lines
indicate actions that always happen, dashed lines are optional:</p>
<pre class="mermaid">%%{init: {'theme':'dark', 'themeVariables': {'fontsize': 20}}}%%
flowchart TD
    InputData[fa:fa-file Calibrated input data]--&gt;Args
    CalSols[fa:fa-file Sky-model source-list file]--&gt;Args
    Settings[fa:fa-cog Other settings]-.-&gt;Args

    Args[fa:fa-cog User arguments]--&gt;Valid{fa:fa-code Valid?}
    Valid --&gt; subtract

    subgraph subtract[For all timesteps]
        Read[fa:fa-code Read a timestep\nof input data]
        Read--&gt;Apply[&quot;fa:fa-code Generate model vis\nand subtract it from input data&quot;]
        Apply--&gt;Write[fa:fa-save Write timeblock\nvisibilities]
    end
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instrumental-polarisations"><a class="header" href="#instrumental-polarisations">Instrumental polarisations</a></h1>
<p>In <code>hyperdrive</code> (and <a href="https://github.com/MWATelescope/mwalib"><code>mwalib</code></a> and
<a href="https://github.com/MWATelescope/mwa_hyperbeam"><code>hyperbeam</code></a>), the X
polarisation refers to the East-West dipoles and the Y refers to North-South.
Note that this contrasts with the IAU definition of X and Y, which is opposite
to this. However, this is consistent within the MWA.</p>
<p>MWA visibilities are ordered XX, XY, YX, YY (using the above definitions of X
and Y).</p>
<h1 id="stokes-polarisations"><a class="header" href="#stokes-polarisations">Stokes polarisations</a></h1>
<p>In <code>hyperdrive</code>:</p>
<ul>
<li>\( \text{XX} = \text{I} + \text{Q} \)</li>
<li>\( \text{XY} = \text{U} + i\text{V} \)</li>
<li>\( \text{YX} = \text{U} - i\text{V} \)</li>
<li>\( \text{YY} = \text{I} - \text{Q} \)</li>
</ul>
<p>where \( \text{I} \), \( \text{Q} \), \( \text{U} \), \( \text{V} \) are
Stokes polarisations and \( i \) is the imaginary unit.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supported-visibility-formats-for-reading"><a class="header" href="#supported-visibility-formats-for-reading">Supported visibility formats for reading</a></h1>
<pre><code class="language-admonish info title=&quot;Raw MWA data&quot;">Raw &quot;legacy&quot; MWA data comes in &quot;gpubox&quot; files. &quot;MWAX&quot; data comes in a similar
format, and `*ch???*.fits` is a useful glob to identify them. Raw data can be
accessed from the [ASVO](https://asvo.mwatelescope.org/).

Here are examples of using each of these MWA formats with `di-calibrate`:

```shell
hyperdrive di-calibrate -d *gpubox*.fits *.metafits *.mwaf -s a_good_sky_model.yaml
hyperdrive di-calibrate -d *ch???*.fits *.metafits *.mwaf -s a_good_sky_model.yaml
```

Note that all visibility formats should probably be accompanied by a metafits
file. See [this page](mwa/metafits.md) for more info.

`mwaf` files indicate what visibilities should be flagged. See [this
page](mwa/mwaf.md) for more info.
</code></pre>
<pre><code class="language-admonish info title=&quot;Measurement sets&quot;">```shell
hyperdrive di-calibrate -d *.ms *.metafits -s a_good_sky_model.yaml
```

Measurement sets are typically made with
[`Birli`](https://github.com/MWATelescope/Birli) or
[`cotter`](https://github.com/MWATelescope/cotter)
([`Birli`](https://github.com/MWATelescope/Birli) preferred). Note that a
metafits is desirable but usually not required. At the time of writing,
MWA-formatted measurement sets do not contain dead dipole information, and so
calibration may not be as accurate as it could be.
</code></pre>
<pre><code class="language-admonish info title=&quot;uvfits&quot;">```shell
hyperdrive di-calibrate -d *.uvfits *.metafits -s a_good_sky_model.yaml
```

When reading uvfits, a metafits is not required *only* if the user has supplied
the MWA dipole delays. At the time of writing, MWA-formatted uvfits files do not
contain dipole delays or dead dipole information, and so avoiding a metafits
file when calibrating may mean it is not as accurate as it could be.

A copy of the uvfits standard is
[here](https://library.nrao.edu/public/memos/aips/memos/AIPSM_117.pdf).
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supported-visibility-formats-for-writing"><a class="header" href="#supported-visibility-formats-for-writing">Supported visibility formats for writing</a></h1>
<p>The following examples illustrate how to produce each of the supported
visibility file formats with <code>solutions-apply</code>, but other aspects of
<code>hyperdrive</code> are also able to produce these file formats, and all aspects are
able to perform averaging and write to multiple outputs.</p>
<pre><code class="language-admonish info title=&quot;Measurement sets&quot;">```shell
hyperdrive solutions-apply \
    -d *gpubox*.fits *.metafits \
    -s hyp_sols.fits \
    -o hyp_cal.ms
```
</code></pre>
<pre><code class="language-admonish info title=&quot;uvfits&quot;">```shell
hyperdrive solutions-apply \
    -d *gpubox*.fits *.metafits \
    -s hyp_sols.fits \
    -o hyp_cal.uvfits
```

A copy of the uvfits standard is
[here](https://library.nrao.edu/public/memos/aips/memos/AIPSM_117.pdf).
</code></pre>
<pre><code class="language-admonish tip title=&quot;Visibility averaging&quot;">When writing out visibilities, they can be averaged in time and frequency. Units
can be given to these; e.g. using seconds and kiloHertz:

```shell
hyperdrive solutions-apply \
    -d *gpubox*.fits *.metafits *.mwaf \
    -s hyp_sols.fits \
    -o hyp_cal.ms \
    --time-average 8s \
    --freq-average 80kHz
```

Units are not required; in this case, these factors multiply the observation's
time and freq. resolutions:

```shell
hyperdrive solutions-apply \
    -d *gpubox*.fits *.metafits *.mwaf \
    -s hyp_sols.fits \
    -o hyp_cal.ms \
    --time-average 4 \
    --freq-average 2
```

If the same observation is used in both examples, with a time resolution of 2s
and a freq. resolution of 40kHz, then both commands will yield the same result.

See [this page](blocks.md) for information on how visibilities are averaged in
time and frequency.
</code></pre>
<pre><code class="language-admonish tip title=&quot;Writing to multiple visibility outputs&quot;">All aspects of `hyperdrive` that can write visibilities can write to multiple
outputs. Note that it probably does not make sense to write out more than one of
each kind (e.g. two uvfits files), as each of these files will be exactly the
same, and a simple `cp` from one to the other is probably faster than writing to
two files simultaneously from `hyperdrive`.

Example (a measurement set and uvfits):
```shell
hyperdrive solutions-apply \
    -d *gpubox*.fits *.metafits *.mwaf \
    -s hyp_sols.fits \
    -o hyp_cal.ms hyp_cal.uvfits \
    --time-average 4 \
    --freq-average 2
```
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metafits-files"><a class="header" href="#metafits-files">Metafits files</a></h1>
<p>The MWA tracks observation metadata with &quot;metafits&quot; files. Often these accompany
the raw visibilities in a download, but these could be old (such as the &quot;PPD
metafits&quot; files). <strong><code>hyperdrive</code> does not support PPD metafits files; only new
metafits files should be used.</strong></p>
<p>This command downloads a new metafits file for the specified observation ID:</p>
<pre><code class="language-admonish example title=&quot;Download MWA metafits file&quot;">```
OBSID=1090008640; wget &quot;http://ws.mwatelescope.org/metadata/fits?obs_id=${OBSID}&quot; -O &quot;${OBSID}&quot;.metafits
```
</code></pre>
<pre><code class="language-admonish info title=&quot;Why should I use a metafits file?&quot;">Measurement sets and uvfits files do not contain MWA-specific information,
particularly dead dipole information. Calibration should perform better when
[dead dipoles](dead_dipoles.md) are taken into account. Measurement sets and
uvfits file may also lack [dipole delay](delays.md) information.
</code></pre>
<pre><code class="language-admonish info title=&quot;Why are new metafits files better?&quot;">The database of MWA metadata can change over time for observations conducted
even many years ago, and the engineering team may decide that some tiles/dipoles
for some observations should be retroactively flagged, or that digital gains
were wrong, etc. In addition, older metafits files may not have all the metadata
that is required to be present by
[`mwalib`](https://github.com/MWATelescope/mwalib), which is used by
`hyperdrive` when reading metafits files.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dipole-delays"><a class="header" href="#dipole-delays">Dipole delays</a></h1>
<p>A tile's dipole delays control where it is &quot;pointing&quot;. Delays are provided as
numbers, and this controls how long a dipole's response is delayed before its
response correlated with other dipoles. This effectively allows the MWA to be
more sensitive in a particular direction without any physical movement.</p>
<p>e.g. This set of dipole delays</p>
<pre><code class="language-plaintext"> 6  4  2  0
 8  6  4  2
10  8  6  4
12 10  8  6
</code></pre>
<p>has the North-East-most (top-right) dipole not being delayed, whereas all others
are delayed by some amount. See <a href="https://wiki.mwatelescope.org/pages/viewpage.action?pageId=48005139">this
page</a> for
more info on dipole ordering.</p>
<p>Dipole delays are usually provided by <a href="defs/mwa/metafits.html">metafits</a> files, but can
also be supplied by command line arguments, e.g.</p>
<pre><code class="language-shell">--delays 6 4 2 0 8 6 4 2 10 8 6 4 12 10 8 6
</code></pre>
<p>would correspond to the example above. Note that these user-supplied delays will
override delays that are otherwise provided.</p>
<p>Dipoles cannot be delayed by more than &quot;31&quot;. &quot;32&quot; is code for <a href="defs/mwa/dead_dipoles.html">&quot;dead
dipole&quot;</a>, which means that these dipoles should not be used
when modelling a tile's response.</p>
<h2 id="ideal-dipole-delays"><a class="header" href="#ideal-dipole-delays">Ideal dipole delays</a></h2>
<p>Most (all?) MWA observations use a single set of delays for all tiles. Dipole
delays are listed in two ways in a metafits file:</p>
<ul>
<li>In the <code>DELAYS</code> key in HDU 1; and</li>
<li>For each tile in HDU 2.</li>
</ul>
<p>The delays in HDU 1 are referred to as &quot;ideal&quot; dipole delays. A set of delays
are not ideal if any are &quot;32&quot; (i.e. dead).</p>
<p>However, the HDU 1 delays may all be &quot;32&quot;. This is an indication from the
observatory that this observation is &quot;bad&quot; and should not be used. <code>hyperdrive</code>
will proceed with such observations but issue a warning. In this case, the ideal
delays are obtained by iterating over all tile delays until each delay is not
32.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dead-dipoles-1"><a class="header" href="#dead-dipoles-1">Dead dipoles</a></h1>
<p>Each MWA tile has 16 &quot;bowties&quot;, and each bowtie is made up of two dipoles (one
X, one Y). We refer to a &quot;dead&quot; dipole as one that is not functioning correctly
(hopefully not receiving any power at all). This information is used in
generating beam responses as part of modelling visibilities. The more accurate
the visibilities, the better that calibration performs, so it is important to
account for dead dipoles if possible.</p>
<p>Beam responses are generated with
<a href="https://github.com/MWATelescope/mwa_hyperbeam"><code>hyperbeam</code></a> and dead dipole
information is encoded as a &quot;dipole gain&quot; of 1 (&quot;alive&quot;) or 0 (&quot;dead&quot;). It is
possible to supply other values for dipole gains, although at the time of
writing <code>hyperdrive</code> only uses ones or zeros.</p>
<p>For the relevant functions, dead dipole information can be ignored by supplying
a flag <code>--unity-dipole-gains</code>. This sets all dipole gains to 1.</p>
<p>At the time of writing, dead dipole information is <em>only</em> supplied by a
<a href="defs/mwa/metafits.html">metafits file</a>.</p>
<p>See <a href="https://wiki.mwatelescope.org/pages/viewpage.action?pageId=48005139">this
page</a> for
more info on dipole ordering.</p>
<p>In the image below, you can see the 12th Y dipole is dead for &quot;Tile022&quot;. All
other dipoles are &quot;alive&quot;.</p>
<p><img src="defs/mwa/dead_dipoles.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mwaf-flag-files"><a class="header" href="#mwaf-flag-files">mwaf flag files</a></h1>
<p><code>mwaf</code> files indicate what visibilities should be flagged, and should be made
with <a href="https://github.com/MWATelescope/Birli"><code>Birli</code></a> (which uses
<a href="https://gitlab.com/aroffringa/aoflagger"><code>AOFlagger</code></a>). They aren't necessary,
but may improve things by removing radio-frequency interference. An example of
producing them is:</p>
<pre><code class="language-shell">birli *gpubox*.fits -m *.metafits -f birli_flag_%%.mwaf
</code></pre>
<p>At the time of writing, <code>hyperdrive</code> only utilises <code>mwaf</code> files when reading
visibilities from raw data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raw-data-corrections"><a class="header" href="#raw-data-corrections">Raw data corrections</a></h1>
<p>A number of things can be done to &quot;correct&quot; or &quot;pre-process&quot; raw MWA data before
it is ready for calibration (or other analysis). These tasks are handled by
<a href="https://github.com/MWATelescope/Birli"><code>Birli</code></a>, either as the <code>Birli</code>
executable itself, or internally in <code>hyperdrive</code>.
<a href="https://github.com/MWATelescope/cotter"><code>cotter</code></a> used to perform these tasks
but it has been superseded by <code>Birli</code>.</p>
<pre><code class="language-admonish info title=&quot;Geometric correction (a.k.a. phase tracking)&quot;">Many MWA observations do not apply a geometric correction despite having a
desired phase centre. This correction applies

\\[ e^{-2 \pi i w_f / \lambda} \\]

to each visibility; note the dependence on baseline \\( w \\) and frequency.

Not performing the geometric correction can have a dramatically adverse effect
on calibration!
</code></pre>
<pre><code class="language-admonish info title=&quot;PFB gains&quot;">The poly-phase filter bank used by the MWA affects visibilities before they get
saved to disk. Over time, a number of &quot;flavours&quot; of these gains have been used:

- &quot;Jake Jones&quot; (`jake`; 200 Hz)
- &quot;cotter 2014&quot; (`cotter2014`; 10 kHz)
- &quot;RTS empirical&quot; (`empirical`; 40 kHz)
- &quot;Alan Levine&quot; (`levine`; 40 kHz)

When correcting raw data, the &quot;Jake Jones&quot; gains are used by default. For each
flavour, the first item in the parentheses (e.g. `cotter2014`) indicates what
should be supplied to `hyperdrive` if you want to use those gains instead. There
is also a `none` &quot;flavour&quot; if you want to disable PFB gain correction.

In CHJ's experience, using different flavours have very little effect on
calibration quality.

Some more information on the PFB can be found
[here](https://wiki.mwatelescope.org/display/MP/RRI+Receiver+PFB+Filter).
</code></pre>
<pre><code class="language-admonish info title=&quot;Cable lengths&quot;">Each tile is connected by a cable, and that cable might have a different length
to others. This correction aims to better align the signals of each tile.
</code></pre>
<pre><code class="language-admonish info title=&quot;Digital gains&quot;">```shell
todo!()
```
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mwalib"><a class="header" href="#mwalib"><code>mwalib</code></a></h1>
<p><a href="https://github.com/MWATelescope/mwalib"><code>mwalib</code></a> is the official MWA
raw-data-reading library. <code>hyperdrive</code> users usually don't need to concern
themselves with it, but <code>mwalib</code> errors may arise.</p>
<h2 id="errors"><a class="header" href="#errors">Errors</a></h2>
<h3 id="missing-a-key-in-the-metafits-file"><a class="header" href="#missing-a-key-in-the-metafits-file">Missing a key in the metafits file</a></h3>
<p><code>mwalib</code> does not support PPD metafits files; only new metafits files should be
used. See the <a href="defs/mwa/metafits.html">metafits</a> page for more info.</p>
<h3 id="others"><a class="header" href="#others">Others</a></h3>
<p>Hopefully the error message alone is clear enough! Please file a <a href="https://github.com/MWATelescope/mwa_hyperdrive/issues">GitHub
issue</a> if something is
confusing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sky-model-source-lists"><a class="header" href="#sky-model-source-lists">Sky-model source lists</a></h1>
<p><code>hyperdrive</code> performs sky-model calibration. Sky-model source lists describe
what the sky looks like, and the closer the sky model matches the data to be
calibrated, the better the calibration quality.</p>
<p>A sky-model source list is composed of many sources, and each source is composed
of at least one component. Each component has a position, a component type and a
flux-density type. Within the code, a source list is a tree structure
associating a source name to a collection of components.</p>
<p>Source list file formats have historically been bespoke. In line with
<code>hyperdrive</code>'s goals, <code>hyperdrive</code> will read many source list formats, but also
presents its own preferred format (which has no limitations within this
software). Each supported format is detailed on the following documentation
pages.</p>
<p><code>hyperdrive</code> can also convert between formats, although in a &quot;lossy&quot; way;
non-<code>hyperdrive</code> formats cannot represent all component and/or flux-density
types.</p>
<pre><code class="language-admonish info title=&quot;Supported formats&quot;">- [`hyperdrive` format](source_list_hyperdrive.md)
- [André Offringa (`ao`) format](source_list_ao.md)
- [`RTS` format](source_list_rts.md)
</code></pre>
<pre><code class="language-admonish info title=&quot;Conversion&quot;">`hyperdrive` can convert (as best it can) between different source list formats.
`hyperdrive srclist-convert` takes the path to input file, and the path to the
output file to be written. If it isn't specified, the type of the input file
will be guessed. Depending on the output file name, the output source list type
may need to be specified.
</code></pre>
<pre><code class="language-admonish info title=&quot;Verification&quot;">`hyperdrive` can be given many source lists in order to test that they are
correctly read. For each input file, `hyperdrive srclist-verify` will print out
what kind of source list the file represents (i.e. `hyperdrive`, `ao`, `rts`,
...) as well as how many sources and components are within the file.
</code></pre>
<pre><code class="language-admonish info title=&quot;Component types&quot;">Each component in a sky model is represented in one of three ways:

- point source
- Gaussian
- shapelet

Point sources are the simplest. Gaussian sources could be considered the same as
point sources, but have details on their structure (major- and minor-axes,
position angle). Finally, shapelets are described the same way as Gaussians but
additionally have multiple &quot;shapelet components&quot;. Examples of each of these
components can be found on the following documentation pages and in the [examples
directory](https://github.com/MWATelescope/mwa_hyperdrive/tree/main/examples).
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flux-density-types"><a class="header" href="#flux-density-types">Flux-density types</a></h1>
<p>This page describes supported flux-density types within <code>hyperdrive</code>. The
following pages detail their usage within sky-model source lists. <a href="defs/modelling/estimating.html">This
page</a> details how each type is estimated in modelling.</p>
<pre><code class="language-admonish info title=&quot;Power laws and Curved power laws&quot;">Most astrophysical sources are modelled as power laws. These are simply
described by a reference Stokes \\( \text{I} \\), \\( \text{Q} \\), \\( \text{U}
\\) and \\( \text{V} \\) flux density at a frequency \\( \nu \\) alongside a
spectral index \\( \alpha \\).

Curved power laws are formalised in Section 4.1 of [Callingham et al.
2017](https://ui.adsabs.harvard.edu/abs/2017ApJ...836..174C/abstract). These are
the same as power laws but with an additional &quot;spectral curvature&quot; parameter \\(
q \\).

Both kinds of power law flux-density representations are preferred in
`hyperdrive`.
</code></pre>
<pre><code class="language-admonish info title=&quot;Flux density lists&quot;">The list type is simply many instances of a Stokes \\( \text{I} \\), \\(
\text{Q} \\), \\( \text{U} \\) and \\( \text{V} \\) value at a frequency.
Example: this source (in the [RTS](source_list_rts.md) style) has 3 defined
frequencies for flux densities:

```plaintext
SOURCE J161720+151943 16.2889374 15.32883
FREQ 80.0e+6 1.45351 0 0 0
FREQ 100.0e+6 1.23465 0 0 0
FREQ 120.0e+6 1.07389 0 0 0
ENDSOURCE
```

In this case, Stokes \\( \text{Q} \\), \\( \text{U} \\) and \\( \text{V} \\) are
all 0 (this is typical), but Stokes \\( \text{I} \\) is 1.45351 Jy at 80 MHz,
1.23465 Jy at 100 MHz and 1.07389 Jy at 120 MHz. This information can be used to
estimate flux densities within the defined frequencies (\\( 80 &lt;=
\nu_{\text{MHz}} &lt;= 120 \\); interpolation) or outside the range (\\(
\nu_{\text{MHz}} &lt; 80 \\) or \\( \nu_{\text{MHz}} &gt; 120 \\); extrapolation).
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-hyperdrive-source-list-format"><a class="header" href="#the-hyperdrive-source-list-format">The <code>hyperdrive</code> source list format</a></h1>
<p>Coordinates are right ascension (RA) and declination, both with units of degrees
in the J2000 epoch. All frequencies are in Hz and all flux densities are in Jy.</p>
<p>All Gaussian and shapelet sizes are in arcsec, but their position angles are in
degrees. In an image space where RA increases from right to left (i.e. bigger RA
values are on the left), position angles rotate counter clockwise. A
position angle of 0 has the major axis aligned with the declination axis.</p>
<p><code>hyperdrive</code>-style source lists can be read from and written to either the
<a href="https://yaml.org/">YAML</a> or <a href="https://www.json.org/json-en.html">JSON</a> file
formats (YAML preferred). Example Python code to read and write these files is
in the <a href="https://github.com/MWATelescope/mwa_hyperdrive/tree/main/examples">examples
directory</a>.</p>
<p>As most sky-models only include Stokes I, Stokes Q, U and V are not required to
be specified. If they are not specified, they are assumed to have values of 0.</p>
<pre><code class="language-admonish example">The following are the contents of a valid YAML file. `super_sweet_source1` is a
single-component point source with a list-type flux density.
`super_sweet_source2` has two components: one Gaussian with a power law, and a
shapelet with a curved power law.

```yaml
---
super_sweet_source1:
  - ra: 10.0
    dec: -27.0
    comp_type: point
    flux_type:
      list:
        - freq: 150000000.0
          i: 10.0
        - freq: 170000000.0
          i: 5.0
          q: 1.0
          u: 2.0
          v: 3.0
super_sweet_source2:
  - ra: 0.0
    dec: -35.0
    comp_type:
      gaussian:
        maj: 20.0
        min: 10.0
        pa: 75.0
    flux_type:
      power_law:
        si: -0.8
        fd:
          freq: 170000000.0
          i: 5.0
          q: 1.0
          u: 2.0
          v: 3.0
  - ra: 155.0
    dec: -10.0
    comp_type:
      shapelet:
        maj: 20.0
        min: 10.0
        pa: 75.0
        coeffs:
          - n1: 0
            n2: 1
            value: 0.5
    flux_type:
      curved_power_law:
        si: -0.6
        fd:
          freq: 150000000.0
          i: 50.0
          q: 0.5
          u: 0.1
        q: 0.2
```
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-andré-offringa-ao-source-list-format"><a class="header" href="#the-andré-offringa-ao-source-list-format">The André Offringa (<code>ao</code>) source list format</a></h1>
<p>This format is used by <code>calibrate</code> within <code>mwa-reduce</code> (closed-source code).</p>
<p>RA is in decimal hours (0 to 24) and Dec is in degrees in the J2000 epoch, but
sexagesimal formatted. All frequencies and flux densities have their units
annotated (although these appear to only be MHz and Jy, respectively).</p>
<p>Point and Gaussian components are supported, but not shapelets. All Gaussian
sizes are in arcsec, but their position angles are in degrees. In an image space
where RA increases from right to left (i.e. bigger RA values are on the left),
position angles rotate counter clockwise. A
position angle of 0 has the major axis aligned with the declination axis.</p>
<p>Flux densities must be specified in the power law or &quot;list&quot; style (i.e. curved
power laws are not supported).</p>
<p>Source names are allowed to have spaces inside them, because the names are
surrounded by quotes. This is fine for reading, but when converting one of these
sources to another format, the spaces need to be translated to underscores.</p>
<pre><code class="language-admonish example">```plaintext
skymodel fileformat 1.1
source {
  name &quot;J002549-260211&quot;
  component {
    type point
    position 0h25m49.2s -26d02m13s
    measurement {
      frequency 80 MHz
      fluxdensity Jy 15.83 0 0 0
    }
    measurement {
      frequency 100 MHz
      fluxdensity Jy 16.77 0 0 0
    }
  }
}
source {
  name &quot;COM000338-1517&quot;
  component {
    type gaussian
    position 0h03m38.7844s -15d17m09.7338s
    shape 89.05978540785397 61.79359416237104 89.07023307815388
    sed {
      frequency 160 MHz
      fluxdensity Jy 0.3276758375536325 0 0 0
      spectral-index { -0.9578697792073567 0.00 }
    }
  }
}
```
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-rts-source-list-format"><a class="header" href="#the-rts-source-list-format">The <code>RTS</code> source list format</a></h1>
<p>Coordinates are right ascension and declination, which have units of decimal
hours (i.e. 0 - 24) and degrees, respectively. All frequencies are in Hz, and
all flux densities are in Jy.</p>
<p>Gaussian and shapelet sizes are specified in arcminutes, whereas position angles
are in degrees. In an image space where RA increases from right to left (i.e.
bigger RA values are on the left), position angles rotate counter clockwise. A
position angle of 0 has the major axis aligned with the declination axis.</p>
<p>All flux densities are specified in the &quot;list&quot; style (i.e. power laws and curved
power laws are not supported).</p>
<p>Keywords like <code>SOURCE</code>, <code>COMPONENT</code>, <code>POINT</code> etc. must be at the start of a line
(i.e. no preceding space).</p>
<p>RTS sources always have a &quot;base source&quot;, which can be thought of as a
non-optional component or the first component in a collection of components.</p>
<pre><code class="language-admonish example">Taken from [srclists](https://github.com/JLBLine/srclists), file
`srclist_pumav3_EoR0aegean_fixedEoR1pietro+ForA_phase1+2.txt`.

Single-component point source:

```plaintext
SOURCE J161720+151943 16.2889374 15.32883
FREQ 80.0e+6 1.45351 0 0 0
FREQ 100.0e+6 1.23465 0 0 0
FREQ 120.0e+6 1.07389 0 0 0
FREQ 140.0e+6 0.95029 0 0 0
FREQ 160.0e+6 0.85205 0 0 0
FREQ 180.0e+6 0.77196 0 0 0
FREQ 200.0e+6 0.70533 0 0 0
FREQ 220.0e+6 0.64898 0 0 0
FREQ 240.0e+6 0.60069 0 0 0
ENDSOURCE
```

Two component Gaussian source:

```plaintext
SOURCE EXT035221-3330 3.8722900 -33.51040
FREQ 150.0e+6 0.34071 0 0 0
FREQ 170.0e+6 0.30189 0 0 0
FREQ 190.0e+6 0.27159 0 0 0
FREQ 210.0e+6 0.24726 0 0 0
GAUSSIAN 177.89089 1.419894937734689 0.9939397975299238
COMPONENT 3.87266 -33.52005
FREQ 150.0e+6 0.11400 0 0 0
FREQ 170.0e+6 0.10101 0 0 0
FREQ 190.0e+6 0.09087 0 0 0
FREQ 210.0e+6 0.08273 0 0 0
GAUSSIAN 2.17287 1.5198465761214996 0.9715267232520484
ENDCOMPONENT
ENDSOURCE
```

Single component shapelet source (truncated):

```plaintext
SOURCE FornaxA 3.3992560 -37.27733
FREQ 185.0e+6 209.81459 0 0 0
SHAPELET2 68.70984356 3.75 4.0
COEFF 0.0 0.0 0.099731291104
COEFF 0.0 1.0 0.002170910745
COEFF 0.0 2.0 0.078201040179
COEFF 0.0 3.0 0.000766942939
ENDSOURCE
```
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calibration-solutions-file-formats"><a class="header" href="#calibration-solutions-file-formats">Calibration solutions file formats</a></h1>
<p>Calibration solutions are Jones matrices that, when applied to raw data,
&quot;calibrate&quot; the visibilities.</p>
<p><code>hyperdrive</code> can convert between supported formats (see <code>solutions-convert</code>).
Soon it will also be able to apply them (but users can write out calibrated
visibilities as part of <code>di-calibrate</code>).</p>
<ul>
<li><a href="defs/cal_sols_hyp.html"><code>hyperdrive</code> format</a></li>
<li><a href="defs/cal_sols_ao.html">André Offringa (<code>ao</code>) format</a></li>
<li><a href="defs/cal_sols_rts.html"><code>RTS</code> format</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-hyperdrive-calibration-solutions-format"><a class="header" href="#the-hyperdrive-calibration-solutions-format">The <code>hyperdrive</code> calibration solutions format</a></h1>
<p>Jones matrices are stored in a <code>fits</code> file as an &quot;image&quot; with 4 dimensions
(timeblock, tile, chanblock, float, in that order) in the &quot;SOLUTIONS&quot; HDU (which
is the second HDU). An element of the solutions is a 64-bit float (a.k.a.
double-precision float). The last dimension always has a length of 8; these
correspond to the real part of XX, the imaginary part of XX, then XY, YX and YY
(4 complex numbers to form a Jones matrix).</p>
<p>Tiles are ordered by antenna number, i.e. the second column in the observation's
corresponding metafits files labelled &quot;Antenna&quot;. Times and frequencies are
sorted ascendingly.</p>
<blockquote>
<p>Note that in the context of the MWA, &quot;antenna&quot; and &quot;tile&quot; are used
interchangeably.</p>
</blockquote>
<h2 id="metadata"><a class="header" href="#metadata">Metadata</a></h2>
<p>Many metadata keys are stored in HDU 1. All keys (in fact, all metadata) are
optional.</p>
<p><code>OBSID</code> describes the MWA observation ID, which is a GPS timestamp.</p>
<p><code>SOFTWARE</code> reports the software used to write this <code>fits</code> file.</p>
<p><code>CMDLINE</code> is the command-line call that produced this <code>fits</code> file.</p>
<h3 id="calibration-specific"><a class="header" href="#calibration-specific">Calibration-specific</a></h3>
<p><code>MAXITER</code> is the maximum number of iterations allowed for each chanblock's
convergence.</p>
<p><code>S_THRESH</code> is the stop threshold of calibration; chanblock iteration ceases once
its precision is better than this.</p>
<p><code>M_THRESH</code> is the minimum threshold of calibration; if a chanblock reaches the
maximum number of iterations while calibrating and this minimum threshold has
not been reached, we say that the chanblock failed to calibrate.</p>
<p><code>UVW_MIN</code> and <code>UVW_MAX</code> are the respective minimum and maximum UVW cutoffs in
metres. Any UVWs below or above these thresholds have baseline weights of 0
during calibration (meaning they effectively aren't used in calibration).
<code>UVW_MIN_L</code> and <code>UVW_MAX_L</code> correspond to <code>UVW_MIN</code> and <code>UVW_MAX</code>, but are in
wavelength units (the <code>L</code> stands for lambda).</p>
<h3 id="raw-mwa-data-corrections"><a class="header" href="#raw-mwa-data-corrections">Raw MWA data corrections</a></h3>
<p><code>PFB</code> describes the <a href="defs/mwa/corrections.html#pfb-gains">PFB gains flavour</a> applied to
the raw MWA data. At the time of writing, this flavour is described as &quot;jake&quot;,
&quot;cotter2014&quot;, &quot;empirical&quot;, &quot;levine&quot;, or &quot;none&quot;.</p>
<p><code>D_GAINS</code> is &quot;Y&quot; if the <a href="defs/../defs/mwa/corrections.html#digital-gains">digital
gains</a> were applied to the raw MWA
data. &quot;N&quot; if they were not.</p>
<p><code>CABLELEN</code> is &quot;Y&quot; if the <a href="defs/../defs/mwa/corrections.html#cable-lengths">cable length
corrections</a> were applied to the raw
MWA data. &quot;N&quot; if they were not.</p>
<p><code>GEOMETRY</code> is &quot;Y&quot; if the <a href="defs/../defs/mwa/corrections.html#geometric-correction-aka-phase-tracking">geometric delay
correction</a>
was applied to the raw MWA data. &quot;N&quot; if they were not.</p>
<h2 id="extra-hdus"><a class="header" href="#extra-hdus">Extra HDUs</a></h2>
<p>More metadata are contained in HDUs other than the first one (that which
contains the metadata keys described above). Other than the first HDU and the
&quot;SOLUTIONS&quot; HDU (HDUs 1 and 2, respectfully), all HDUs are optional.</p>
<h3 id="timeblocks"><a class="header" href="#timeblocks">TIMEBLOCKS</a></h3>
<p>The &quot;TIMEBLOCKS&quot; HDU is a FITS table with three columns:</p>
<ol>
<li><code>Start</code></li>
<li><code>End</code></li>
<li><code>Average</code></li>
</ol>
<p>Each row represents a timeblock, and there must be the same number of rows as
there are timeblocks in the calibration solutions (in the &quot;SOLUTIONS&quot; HDU). Each
of these times is a centroid GPS timestamp.</p>
<p>It is possible to have one or multiple columns without data; <code>cfitsio</code> will
write zeros for values, but <code>hyperdrive</code> will ignore columns with all zeros.</p>
<p>While average times are likely just the median of its corresponding start and
end times, it need not be so; in this case, it helps to clarify that some
timesteps in this calibration timeblock were not used. e.g. a start time of 10
and an end time of 16 probably has an average time of 13, but, if 3 of 4
timesteps in this timeblock are used, then the average time could be 12.666 or
13.333.</p>
<h3 id="tiles"><a class="header" href="#tiles">TILES</a></h3>
<p>The &quot;TILES&quot; HDU is a FITS table with three columns:</p>
<ol>
<li><code>Antenna</code></li>
<li><code>TileName</code></li>
<li><code>Flag</code></li>
</ol>
<p><code>Antenna</code> is the 0-N antenna index (where N is the total number of antennas in
the observation). These indices match the &quot;Antenna&quot; column of an <a href="defs/mwa/metafits.html">MWA
metafits</a> file.</p>
<p><code>TileName</code> is the... name of the tile. As with <code>Antenna</code>, this should match the
contents of an MWA metafits file.</p>
<p><code>Flag</code> is a boolean indicating whether an antenna was flagged during calibration
(1) or not (0).</p>
<h3 id="chanblocks"><a class="header" href="#chanblocks">CHANBLOCKS</a></h3>
<p>See <a href="defs/blocks.html">blocks</a> for an explanation of what chanblocks are.</p>
<p>The &quot;CHANBLOCKS&quot; HDU is a FITS table with two columns:</p>
<ol>
<li><code>Index</code></li>
<li><code>Freq</code></li>
<li><code>Flag</code></li>
</ol>
<p><code>Index</code> is the 0-N chanblock index (where N is the total number of chanblocks in
the observation). Note that this is not necessarily the same as the total number
of <em>channels</em> in the observation; channels may be averaged before calibration,
making the number of chanblocks less than the number of channels.</p>
<p><code>Freq</code> is the centroid frequency of the chanblock (as a double-precision float).
If <em>any</em> of the frequencies is an NaN, then <code>hyperdrive</code> will not use the <code>Freq</code>
column.</p>
<p><code>Flag</code> indicates whether calibration was attempted (1) or not (0) on a chanblock
(boolean).</p>
<h3 id="results-calibration-results"><a class="header" href="#results-calibration-results">RESULTS (Calibration results)</a></h3>
<p>The &quot;RESULTS&quot; HDU is a FITS image with two dimensions -- timeblock and
chanblock, in that order -- that describe the precision to which a chanblock
converged for that timeblock (as double-precision floats). If a chanblock was
flagged, NaN is provided for its precision. NaN is also listed for chanblocks
that completely failed to calibrate.</p>
<p>These calibration precisions must have the same number of timeblocks and
chanblocks described by the calibration solutions (in the &quot;SOLUTIONS&quot; HDU).</p>
<h3 id="baselines"><a class="header" href="#baselines">BASELINES</a></h3>
<p>The &quot;BASELINES&quot; HDU is a FITS image with one dimension. The values of the
&quot;image&quot; (let's call it an array) are the double-precision float baseline weights
used in calibration (controlled by UVW minimum and maximum cutoffs). The length
of the array is the total number of baselines (i.e. flagged and unflagged).
Flagged baselines have weights of NaN, e.g. baseline 0 is between antennas 0 and
1, but if antenna 1 is flagged, the weight of baseline 0 is NaN, but baseline 1
is between antennas 0 and 2 so it has a value other than NaN.</p>
<p>These baseline weights must have a non-NaN value for all tiles in the
observation (e.g. if there are 128 tiles in the calibration solutions, then
there must be 8128 baseline weights).</p>
<pre><code class="language-admonish example title=&quot;Python code for reading&quot;">A full example of reading and plotting solutions is
[here](https://github.com/MWATelescope/mwa_hyperdrive/blob/main/examples/read_hyperdrive_sols.py),
but simple examples of reading solutions and various metadata are below.

```python
#!/usr/bin/env python3

from astropy.io import fits

f = fits.open(&quot;hyperdrive_solutions.fits&quot;)
sols = f[&quot;SOLUTIONS&quot;].data
num_timeblocks, num_tiles, num_chanblocks, _ = sols.shape

obsid = f[0].header[&quot;OBSID&quot;]
pfb_flavour = f[0].header[&quot;PFB&quot;]
start_times = f[0].header[&quot;S_TIMES&quot;]

tile_names = [tile[1] for tile in f[&quot;TILES&quot;].data]
tile_flags = [tile[2] for tile in f[&quot;TILES&quot;].data]

freqs = [chan[1] for chan in f[&quot;CHANBLOCKS&quot;].data]

cal_precisions_for_timeblock_0 = f[&quot;RESULTS&quot;].data[0]
```
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-andré-offringa-ao-calibration-solutions-format"><a class="header" href="#the-andré-offringa-ao-calibration-solutions-format">The André Offringa (<code>ao</code>) calibration solutions format</a></h1>
<p>This format is output by <code>calibrate</code> and is documented in <code>mwa-reduce</code> as
follows. Note that the <code>startTime</code> and <code>endTime</code> should be populated with &quot;AIPS
time&quot;, although <code>calibrate</code> appears to always write 0 for these. <code>hyperdrive</code>
instead opts to write the centroid GPS times here (the end time is the last
timestep inclusive).</p>
<p>Tiles are ordered by antenna number, i.e. the second column in the observation's
corresponding metafits files labelled &quot;antenna&quot;. Times and frequencies are
sorted ascendingly.</p>
<h2 id="mwa-reduce-documentation"><a class="header" href="#mwa-reduce-documentation"><code>mwa-reduce</code> documentation</a></h2>
<pre><code class="language-text">| Bytes  |  Description |
|-------:|:-------------|
|  0- 7  |  string intro ; 8-byte null terminated string &quot;MWAOCAL&quot; |
|  8-11  |  int fileType ; always 0, reserved for indicating something other than complex Jones solutions |
| 12-15  |  int structureType ; always 0, reserved for indicating different ordering |
| 16-19  |  int intervalCount ; Number of solution intervals in file |
| 20-23  |  int antennaCount ; Number of antennas that were in the measurement set (but were not necessary all solved for) |
| 24-27  |  int channelCount ; Number of channels in the measurement set |
| 28-31  |  int polarizationCount ; Number of polarizations solved for -- always four. |
| 32-39  |  double startTime ; Start time of solutions (AIPS time) |
| 40-47  |  double endTime ; End time of solutions (AIPS time) |
</code></pre>
<p>After the header follow 2 x nSolution doubles, with</p>
<p>nSolutions = nIntervals * nAntennas * nChannels * nPols</p>
<p>Ordered in the way as given, so:
double 0 : real of interval 0, antenna 0, channel 0, pol 0
double 1 : imaginary of interval 0, antenna 0, channel 0, pol 0
double 2 : real of interval 0, antenna 0, channel 0, pol 1
...
double 8 : real of interval 0, antenna 0, channel 1, pol 0
double nChannel x 8 : real of interval 0, antenna 1, channel 0, pol 0
etc.</p>
<p>here, ints are always 32 bits unsigned integers, doubles are IEEE double precision 64 bit floating points.
If a solution is not available, either because no data were selected during calibration for this interval
or because the calibration diverged, a &quot;NaN&quot; will be stored in the doubles belonging to that solution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-rts-calibration-solutions-format"><a class="header" href="#the-rts-calibration-solutions-format">The <code>RTS</code> calibration solutions format</a></h1>
<p><img src="https://media.giphy.com/media/NsIwMll0rhfgpdQlzn/giphy.gif" alt="" /></p>
<p>todo!()</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="beam-responses"><a class="header" href="#beam-responses">Beam responses</a></h1>
<p>Beam responses are given by
<a href="https://github.com/MWATelescope/mwa_hyperbeam"><code>mwa_hyperbeam</code></a>. At present,
only MWA beam code is used.</p>
<p>To function, MWA beam code needs a few things:</p>
<ul>
<li>The <a href="defs/mwa/delays.html">dipole delays</a>;</li>
<li>The <a href="defs/mwa/dead_dipoles.html">dipole gains</a> (usually dead dipoles are 0, others are 1);</li>
<li>The direction we want the beam response as an Azimuth-Elevation coordinate; and</li>
<li>A frequency.</li>
</ul>
<p>In addition, the FEE beam code needs an HDF5 file to function. See the
<a href="defs/../installation/post.html">post-installation instructions</a> for information on
getting that set up.</p>
<h2 id="errors-1"><a class="header" href="#errors-1">Errors</a></h2>
<p>Beam code usually does not error, but if it does it's likely because:</p>
<ol>
<li>There aren't exactly 16 dipole delays;</li>
<li>There aren't exactly 16 or 32 dipole gains per tile; or</li>
<li>There's something wrong with the FEE HDF5 file. The official file is well
tested.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modelling-visibilities"><a class="header" href="#modelling-visibilities">Modelling visibilities</a></h1>
<p><code>hyperdrive</code> uses a sky model when modelling/simulating visibilities. This means
that for every sky-model source, a visibility needs to be generated for each
observation time, baseline and frequency. Modelling visibilities for a source
can be broken down into three broad steps:</p>
<ul>
<li><a href="defs/modelling/estimating.html">Estimating</a> a source's flux density at a particular frequency;</li>
<li>Getting the baseline's beam response toward the source; and</li>
<li>Applying these factors to the result of the <a href="defs/modelling/rime.html">measurement equation</a>.</li>
</ul>
<p>Beam responses are given by
<a href="https://github.com/MWATelescope/mwa_hyperbeam"><code>mwa_hyperbeam</code></a>. See more info
on the beam <a href="defs/modelling/../beam.html">here</a>.</p>
<p>The following pages go into further detail of how visibilities are modelled in
<code>hyperdrive</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="measurement-equation"><a class="header" href="#measurement-equation">Measurement equation</a></h1>
<pre><code class="language-admonish">A lot of this content was taken from [Jack Line's
`WODEN`](https://github.com/JLBLine/WODEN).
</code></pre>
<p>The measurement equation (also known as the Radio Interferometer Measurement
Equation; RIME) used in <code>hyperdrive</code>'s calculations is:</p>
<p>\[ V_{s,f}(u_f,v_f,w_f) = \int\int S_{s,f}(l,m) e^{2 \pi i \phi} \frac{dl dm}{n} \]</p>
<p>where</p>
<ul>
<li>\( V_{s,f}(u_f,v_f,w_f) \) is the measured visibility in some Stokes
polarisation \( s \) for some frequency \( f \) at baseline coordinates
\( u_f, v_f, w_f \);</li>
<li>\( S_{s,f} \) is the apparent brightness in the direction \( l, m \) at
the same frequency \( f \);</li>
<li>\( i \) is the imaginary unit;</li>
<li>\( \phi = \left(u_fl + v_fm + w_f(n-1) \right) \); and</li>
<li>\( n = \sqrt{1 - l^2 - m^2} \).</li>
</ul>
<p>As we cannot ever have the true \( S_{s,f} \) function, we approximate with a
sky-model source list, which details the expected positions and brightnesses of
sources. This effectively turns the above continuous equation into a discrete
one:</p>
<p>\[ V_{s,f}(u_f,v_f,w_f) = \sum S_{s,f}(l,m) e^{2 \pi i \left(u_fl + v_fm + w_f(n-1) \right)} \]</p>
<p><code>hyperdrive</code> implements this equation as code, either on the CPU or GPU
(preferred), and it is a good example of an embarrassingly parallel problem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="estimating-flux-densities"><a class="header" href="#estimating-flux-densities">Estimating flux densities</a></h1>
<p>The algorithm used to estimate a sky-model component's flux density depends on
the <a href="defs/modelling/../fd_types.html">flux-density type</a>.</p>
<p>Note that in the calculations below, flux densities are allowed to be negative.
It is expected, however, that a sky-model component with a negative flux density
belongs to a source with multiple components, and that the overall flux density
of that source at any frequency is positive. A source with a negative flux
density is not physical.</p>
<pre><code class="language-admonish info title=&quot;Power laws and Curved power laws&quot;">Both power-law and curved-power-law sources have a spectral index (\\( \alpha
\\)) and a reference flux density (\\( S_0 \\)) defined at a particular
frequency (\\( \nu_0 \\)). In addition to this, curved power laws have a
curvature term (\\( q \\)).

To estimate a flux density (\\( S \\)) at an arbitrary frequency (\\( \nu \\)), a
ratio is calculated:

\\[ r = \left(\frac{\nu}{\nu_0}\right)^\alpha \\]

For power laws, \\( S \\) is simply:

\\[ S = S_0 r \\]

whereas another term is needed for curved power laws:

\\[ c = \exp\left({q \ln\left(\frac{\nu}{\nu_0}\right)^2 }\right) \\]
\\[ S = S_0 r c \\]

\\( S \\) can represent a flux density for Stokes \\( \text{I} \\), \\( \text{Q}
\\), \\( \text{U} \\) or \\( \text{V} \\). The same \\( r \\) and \\( c \\)
values are used for each Stokes flux density.
</code></pre>
<pre><code class="language-admonish info title=&quot;Flux density lists&quot;">To estimate a flux density (\\( S \\)) at an arbitrary frequency (\\( \nu \\)),
a number of considerations must be made.

In the case that a list only has one flux density, we must assume that it is a
power law, use a default spectral index (\\( -0.8 \\)) for it and follow the
algorithm above.

In all other cases, there are at least two flux densities in the list (\\( n &gt;=
2 \\)). We find the two list frequencies (\\( \nu_i \\)) and (\\( \nu_j \\))
closest to \\( \nu \\) (these can both be smaller and larger than \\( \nu \\)).
If the flux densities \\( S_i \\) and \\( S_j \\) are both positive or both
negative, we proceed with the power law approach: A spectral index is calculated
with \\( \nu_i \\) and \\( \nu_j \\) (\\( \alpha \\)) and used to estimate a
flux density with the power law algorithm. If \\( \alpha &lt; -2.0 \\) (the
&quot;spectral-index cap&quot;), we set \\( \alpha = 2 \\).

If the signs of \\( S_i \\) and \\( S_j \\) are opposites, then we cannot fit a
spectral index. Instead, we fit a straight between \\( S_i \\) and \\( S_j \\)
and use the straight line to estimate \\( S \\).

No estimation is required when \\( \nu \\) is equal to any of the list
frequencies \\( \nu_i \\).
</code></pre>
<pre><code class="language-admonish danger title=&quot;Concerns on list types&quot;">When estimating flux densities from a list, it is feared that the &quot;jagged&quot; shape
of a component's spectral energy distribution introduces artefacts into an EoR
power spectrum.

It is relatively expensive to estimate flux densities from a list type. For all
these reasons, users are strongly encouraged to not use list types where
possible.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timeblocks-1"><a class="header" href="#timeblocks-1">Timeblocks</a></h1>
<p>A timeblock is an averaged unit of timesteps. The number of timesteps per
timeblock is determined by the user, but it is always at least 1. An observation
may be calibrated in multiple timeblocks, e.g. 4 timesteps per timeblock. If the
same observation has more than 4 timesteps, then there are multiple calibration
timeblocks, and time-varying effects can be seen. Here's a representation of an
observation with 10 timesteps and 4 timesteps per timeblock:</p>
<pre><code class="language-text">Timeblock 1    Timeblock 2   Timeblock 3
[[0, 1, 2, 3], [4, 5, 6, 7], [8, 9]]
</code></pre>
<p>Timeblocks do not need to be contiguous and can be sparse, e.g. for an
observation containing 10 timesteps (starting at timestep 0):</p>
<pre><code class="language-text">    Timeblock 1            Timeblock 2
[_, [1, _, 3],  [_, _, _], [_, _, 9]]
</code></pre>
<p>is a valid representation of how the data would be averaged if there are 3
timesteps per timeblock. In this case, the <strong>timestamps</strong> of each timeblock
correspond to the timestamps of timesteps 2 and 8.</p>
<p>Timeblock are also used in writing out averaged visibilities. If there are 4
timesteps per timeblock, then the output visibilities might be 4x smaller than
the input visibilities (depending on how the timesteps align with the
timeblocks).</p>
<h1 id="chanblocks-1"><a class="header" href="#chanblocks-1">Chanblocks</a></h1>
<p>Similar to timeblocks, chanblocks are averaged units of channels. Frequency
averaging is currently only implemented when writing out visibilities, so there
is not much discussion needed here, yet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-dimension-arrays-ndarray"><a class="header" href="#multiple-dimension-arrays-ndarray">Multiple-dimension arrays (<code>ndarray</code>)</a></h1>
<p><a href="https://docs.rs/ndarray/latest/ndarray/"><code>ndarray</code></a>s are used liberally
throughout <code>hyperdrive</code> (and its dependencies). <code>ndarray</code>'s usage is a little
different to the usual Rust vectors and slices. This page hopes to help
developers understand what some of the loops using <code>ndarray</code>s is doing.</p>
<p>Here's a simplified example:</p>
<pre><code class="language-rust ignore">use marlu::Jones;
use ndarray::Array3;

// Set up `vis` and `weights` to be 3D arrays. The dimensions are time,
// baseline, channel.
let shape = (2, 8128, 768);
let mut vis: Array3&lt;Jones&lt;f32&gt;&gt; = Array3::from_elem(shape, Jones::identity());
let mut weights: Array3&lt;f32&gt; = Array3::ones(shape);
// `outer_iter_mut` mutably iterates over the slowest dimension (in this
// case, time).
vis.outer_iter_mut()
    // Iterate over weights at the same time as `vis`.
    .zip(weights.outer_iter_mut())
    // Also get an index of how far we are into the time dimension.
    .enumerate()
    .for_each(|(i_time, (mut vis, mut weights))| {
        // `vis` and `weights` are now 2D arrays. `i_time` starts from 0 and
        // is an index for the time dimension.
        vis.outer_iter_mut()
            .zip(weights.outer_iter_mut())
            .enumerate()
            .for_each(|(i_bl, (mut vis, mut weights))| {
                // `vis` and `weights` are now 1D arrays. `i_bl` starts from
                // 0 and is an index for the baseline dimension.

                // Use standard Rust iterators to get the
                // elements of the 1D arrays.
                vis.iter_mut().zip(weights.iter_mut()).enumerate().for_each(
                    |(i_chan, (vis, weight))| {
                        // `vis` is a mutable references to a Jones matrix
                        // and `weight` is a mutable reference to a float.
                        // `i_chan` starts from 0 and is an index for the
                        // channel dimension.
                        // Do something with these references.
                        *vis += Jones::identity() * (i_time + i_bl + i_chan) as f32;
                        *weight += 2.0;
                    },
                );
            });
    });
</code></pre>
<h2 id="views"><a class="header" href="#views">Views</a></h2>
<p>It is typical to pass Rust <code>Vec</code>s around as slices, i.e. a <code>Vec&lt;f64&gt;</code> is
borrowed as a <code>&amp;[f64]</code>. Similarly, one might be tempted to make a function
argument a borrowed <code>ndarray</code>, e.g. <code>&amp;Array3&lt;f64&gt;</code>, but there is a better way.
Calling <code>.view()</code> or <code>.view_mut()</code> on an <code>ndarray</code> yields an <code>ArrayView</code> or
<code>ArrayViewMut</code>, which can be any subsection of the full array. By using views we
can avoid requiring a borrow of the whole array when we only want a part of it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="non-empty-vectors-vec1"><a class="header" href="#non-empty-vectors-vec1">Non-empty vectors (<code>vec1</code>)</a></h1>
<p>See the <a href="https://docs.rs/vec1/latest/vec1/">official docs</a> for more info.</p>
<p>Why do we use <code>Vec1</code> instead of <code>Vec</code>? Can't we just assume that all our vectors
are not empty? Well, we could, but then:</p>
<ol>
<li>
<p>We'd probably be wrong at some point in the future;</p>
</li>
<li>
<p>We're making the code inject panic code somewhere it probably doesn't need to; and</p>
</li>
<li>
<p>We can do better than this.</p>
</li>
</ol>
<p><a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">This
article</a>,
although catered for Haskell, presents the case well. Put simply, if we require
something to be non-empty, then we can express that with a type, and this means
we don't need to re-validate its non-empty-ness after its creation.</p>
<p>We can also avoid using <code>Vec</code> by using <code>Option&lt;Vec1&gt;</code>; we still need to check
whether we have <code>Some</code> or <code>None</code>, but doing so is better than assuming a <code>Vec</code>
is non-empty.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
